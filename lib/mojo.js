// Generated by CoffeeScript 1.6.2
(function() {
  var EventEmitter, mongodb,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  mongodb = require('mongodb');

  EventEmitter = require('events').EventEmitter;

  exports.Connection = (function(_super) {
    __extends(Connection, _super);

    function Connection(options) {
      options || (options = {});
      this.ensureConnection(options);
      this.expires = options.expires || 60 * 60 * 1000;
      this.timeout = options.timeout || 10 * 1000;
    }

    Connection.prototype.ensureConnection = function(opt) {
      var afterConnectionEstablished, db, server,
        _this = this;

      this.queue = [];
      afterConnectionEstablished = function(err) {
        if (err) {
          _this.emit('error', err);
        }
        return db.collectionNames(function(err) {
          if (err) {
            _this.emit('error', err);
          }
          return db.collection('mojo', function(err, collection) {
            var fn, _i, _len, _ref;

            if (err) {
              _this.emit('error', err);
            }
            _this.mojo = collection;
            if (_this.queue) {
              _ref = _this.queue;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                fn = _ref[_i];
                fn(collection);
              }
            }
            delete _this.queue;
            return collection.ensureIndex([['expires'], ['owner'], ['queue']], function(err) {
              if (err) {
                return this.emit('error', err);
              }
            });
          });
        });
      };
      if (opt.db instanceof mongodb.Db) {
        db = opt.db;
        return afterConnectionEstablished(null);
      }
      server = new mongodb.Server(opt.host || '127.0.0.1', opt.port || 27017);
      return new mongodb.Db(opt.db || 'queue', server, {
        w: 1
      }).open(function(err, _db) {
        if (err) {
          _this.emit('error', err);
        }
        if (_db) {
          db = _db;
        }
        if (opt.username && opt.password) {
          return db.authenticate(opt.username, opt.password, afterConnectionEstablished);
        } else {
          return afterConnectionEstablished(null);
        }
      });
    };

    Connection.prototype.exec = function(fn) {
      return this.queue && this.queue.push(fn) || fn(this.mojo);
    };

    Connection.prototype.clear = function(queue, callback) {
      return this.exec(function(mojo) {
        return mojo.remove({
          queue: queue
        }, callback);
      });
    };

    Connection.prototype.enqueue = function() {
      var args, callback, expires, queue, _i;

      queue = arguments[0], args = 3 <= arguments.length ? __slice.call(arguments, 1, _i = arguments.length - 1) : (_i = 1, []), callback = arguments[_i++];
      expires = new Date(new Date().getTime() + this.expires);
      return this.exec(function(mojo) {
        return mojo.insert({
          queue: queue,
          expires: expires,
          args: args
        }, callback);
      });
    };

    Connection.prototype.next = function(queue, owner, callback) {
      var now, query, timeout;

      now = new Date;
      timeout = new Date(now.getTime() + this.timeout);
      query = {
        expires: {
          $gt: now
        },
        owner: null
      };
      if (queue) {
        query.queue = queue;
      }
      return this.exec(function(mojo) {
        return mojo.findAndModify(query, 'expires', {
          $set: {
            timeout: timeout,
            owner: owner
          }
        }, {
          "new": 1
        }, callback);
      });
    };

    Connection.prototype.complete = function(doc, callback) {
      return this.exec(function(mojo) {
        return mojo.findAndModify({
          _id: doc._id
        }, 'expires', {}, {
          remove: 1
        }, callback);
      });
    };

    Connection.prototype.release = function(doc, callback) {
      return this.exec(function(mojo) {
        return mojo.findAndModify({
          _id: doc._id
        }, 'expires', {
          $unset: {
            timeout: 1,
            owner: 1
          }
        }, {
          "new": 1
        }, callback);
      });
    };

    Connection.prototype.cleanup = function(callback) {
      return this.exec(function(mojo) {
        return mojo.update({
          timeout: {
            $lt: new Date
          }
        }, {
          $unset: {
            timeout: 1,
            owner: 1
          }
        }, {
          multi: 1
        }, callback);
      });
    };

    return Connection;

  })(EventEmitter);

  exports.Template = (function() {
    function Template(worker, doc) {
      this.worker = worker;
      this.doc = doc;
    }

    Template.prototype.invoke = function() {
      var err;

      try {
        return this.perform.apply(this, this.doc.args);
      } catch (_error) {
        err = _error;
        return this.complete(err);
      }
    };

    Template.prototype.perform = function() {
      var args;

      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      throw new Error('Yo, you need to implement me!');
    };

    Template.prototype.complete = function(err) {
      return this.worker.complete(err, this.doc);
    };

    return Template;

  })();

  exports.Worker = (function(_super) {
    __extends(Worker, _super);

    function Worker(connection, templates, options) {
      this.connection = connection;
      this.templates = templates;
      options || (options = {});
      this.name = [require('os').hostname(), process.pid].join(':');
      this.timeout = options.timeout || 1000;
      this.rotate = options.rotate || false;
      this.workers = options.workers || 3;
      this.pending = 0;
    }

    Worker.prototype.poll = function() {
      var Template, templateName,
        _this = this;

      if (this.pending >= this.workers) {
        return this.sleep();
      }
      Template = this.getTemplate();
      templateName = Template ? Template.name : void 0;
      return this.connection.next(templateName, this.name, function(err, doc) {
        if ((err != null) && err.message !== 'No matching object found') {
          _this.emit('error', err);
        } else if (doc != null) {
          ++_this.pending;
          if (!Template) {
            Template = _this.getTemplate(doc.queue);
          }
          if (Template) {
            new Template(_this, doc).invoke();
          } else {
            _this.emit('error', new Error("Unknown template '" + name + "'"));
          }
          process.nextTick(function() {
            return _this.poll();
          });
        }
        return _this.sleep();
      });
    };

    Worker.prototype.getTemplate = function(name) {
      var Template,
        _this = this;

      Template = null;
      if (name) {
        this.templates.some(function(_Template) {
          if (_Template.name === name) {
            Template = _Template;
            return true;
          }
        });
      } else if (this.rotate) {
        Template = this.templates.shift();
        this.templates.push(Template);
      }
      return Template;
    };

    Worker.prototype.sleep = function() {
      var _this = this;

      if (this.pollTimeout) {
        clearTimeout(this.pollTimeout);
      }
      return this.pollTimeout = setTimeout(function() {
        _this.pollTimeout = null;
        return _this.poll();
      }, this.timeout);
    };

    Worker.prototype.complete = function(err, doc) {
      var cb,
        _this = this;

      cb = function() {
        --_this.pending;
        return _this.poll();
      };
      if (err != null) {
        return this.connection.release(doc, cb);
      } else {
        return this.connection.complete(doc, cb);
      }
    };

    return Worker;

  })(require('events').EventEmitter);

}).call(this);
